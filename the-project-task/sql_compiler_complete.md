# SQL Compiler Project - Complete Requirements

**University:** Damascus University - Faculty of Informatics Engineering  
**Year:** Fourth Year  
**Department:** Artificial Intelligence  
**Course:** Practical Compilers  

---

## Project Overview

Build a complete compiler for SQL language (target language) using ANTLR 4 tool. The compiler will consist of three main phases:
1. Lexical Analysis (Lexical Analyzer)
2. Syntax Analysis (Parser)
3. Abstract Syntax Tree (AST) Construction and Display

---

# PHASE 1: Lexical Analyzer

## Objective

The lexical analysis is the first phase of compiler construction. The main task is to read sequences of input characters and produce a series of tokens (words/symbols).

## Requirements

Build a lexical analyzer using ANTLR 4 tool to recognize all possible tokens in SQL language.

### Implementation Details

- Place pattern rules in the `.g4` file's rules section
- Define regular expressions for each token type
- **Input:** A file containing SQL code
- **Output:** All tokens found in the SQL code

### Tokens to Recognize (Minimum Required)

#### 1. Reserved Keywords
- All Transact-SQL reserved keywords

#### 2. Numbers
- Integer Numbers
- Float Numbers

#### 3. Boolean
- Boolean literals

#### 4. Strings
- Literal Strings
- Hex Strings
- Bit Strings

#### 5. Operators
- Arithmetic operators
- Logical operators
- Comparison operators

#### 6. Identifiers
- Table names
- Column names
- Stored procedures
- Variable names

#### 7. User Variables
- Variables starting with `@` or `@@`

#### 8. Comments
- Single Line Comments (`--`)
- Multi Line Comments (`/* */`)

### Special Cases to Handle

| Case | Example | Notes |
|------|---------|-------|
| Escaped Single Quote in String | `SELECT 'It''s a beautiful day.' AS Value` | Use two single quotes |
| Nested Comments | `/* SELECT @comment = '/*'; */ */` | Support nested comment structures |
| Splitting a Character String | `SELECT 'abc\ def' AS [ColumnResult];` | Handle line continuation with backslash |
| Splitting a Binary String | `SELECT 0xabc\def AS [ColumnResult];` | Handle hex string continuation |

---

# PHASE 2: Syntax Analysis

## Objective

Verify that a sequence of tokens conforms to the grammar rules of SQL language. Answer the question: "Does the token sequence belong to the language generated by the Grammar?"

## Requirements

Write a comprehensive set of grammar rules for SQL using ANTLR 4 parser tool.

### Grammar Rules to Implement

#### DML Statements (Data Manipulation Language)
- `select_statement` - SELECT queries
- `update_statement` - UPDATE queries
- `delete_statement` - DELETE queries
- `insert_statement` - INSERT queries
- Additional DML statements

#### DDL Statements (Data Definition Language)
- `DROP` - Drop objects
- `ALTER` - Modify objects
- `CREATE` - Create objects
- Additional DDL statements

#### Cursor Manipulation Statements
- Cursor operations

#### Common Table Expression (CTE) Statements
- WITH clauses
- Recursive CTEs

### Grammar Conflict Resolution

Resolve conflicts using:
- **Associativity** concepts for operations
- **Precedence** rules for operator priority
- Mathematical operation precedence
- Logical operation precedence

### Reference Documentation

Use Transact-SQL documentation as reference:
- https://learn.microsoft.com/en-us/sql/t-sql/queries/queries?view=sql-server-ver17

### SQL Documentation Notation to ANTLR 4 Conversion Guide

#### 1. Angle Brackets `<...>` → Non-Terminal Rules
**SQL Doc:** `<common_table_expression>`  
**ANTLR 4:** 
```antlr
commonTableExpression
```

#### 2. Square Brackets `[...]` → Optional Elements (?)
**SQL Doc:** `[ WHERE <search_condition> ]`  
**ANTLR 4:**
```antlr
whereClause?
```

#### 3. Curly Braces `{...}` → Choice (|)
**SQL Doc:** `{ table_alias | <object> | rowset_function_limited }`  
**ANTLR 4:**
```antlr
tableAlias
| objectName
| rowsetFunctionLimited
```

#### 4. Ellipsis `[,...n]` → Repetition (*)
**SQL Doc:** `SET a=1, b=2, c=3` (comma-separated list)  
**ANTLR 4:**
```antlr
assignment (',' assignment)*
```

#### 5. Keywords in UPPERCASE → Tokens
**SQL Doc:** `UPDATE`, `SET`, `WHERE`, `FROM`  
**ANTLR 4:** Use uppercase token names directly in rules

### Implementation Strategy

**Do NOT directly translate SQL documentation syntax into grammar rules.** Instead:

1. Use documentation as reference to understand language structure
2. Translate the logical meaning into ANTLR 4 grammar
3. Start with a small subset of rules
4. Gradually add features while testing

### Example: SELECT Statement Development

**Phase 1 - Basic SELECT:**
```sql
SELECT column1, column2 FROM table1
```

**Phase 2 - Add WHERE Clause:**
```sql
SELECT column1, column2 FROM table1 WHERE column1 = 'hello world'
```

**Phase 3 - Add Advanced Features:**
- JOIN operations
- GROUP BY clause
- HAVING clause
- ORDER BY clause
- Subqueries
- Aggregate functions
- And other features

---

# PHASE 3: Abstract Syntax Tree (AST) Construction

## Objective

Build and display the Abstract Syntax Tree representing the structure of the SQL program after syntactic validation.

### AST Overview

**Abstract Syntax Tree (AST)** is a data structure that represents the structure of a program in abstract form. It:
- Omits punctuation marks (semicolons, colons)
- Omits parentheses and brackets
- Represents the logical structure of the code
- Excludes syntactic details unnecessary for semantic analysis

### Elements NOT Included in AST

- Punctuation marks (`;`, `:`)
- Parentheses `( )`
- Square brackets `[ ]`
- Angle brackets `< >`
- Other syntactic symbols

## Implementation Requirements

### Architecture Overview

```
Input SQL Code
    ↓
Phase 1: Lexical Analyzer
    ↓ Generates Tokens
Phase 2: Syntax Parser
    ↓ Generates Parse Tree
Phase 3: AST Builder
    ↓ Generates AST
AST Output and Display
```

### Step 1: Define AST Model Package

#### 1.1 Abstract Base Class: ASTNode

Create an abstract base class `ASTNode` that contains:
- Data members for common node properties
- Common methods shared by all node types
- Abstract `print()` method for tree printing
- Abstract methods to be implemented by child classes

#### 1.2 Classes for Non-Terminal Symbols

For each **non-terminal** symbol in the grammar:
- Create a separate class
- Inherit from `ASTNode`
- Include child node references
- Implement node-specific logic

**Example Non-Terminal Classes:**
```
SelectStatement (extends ASTNode)
UpdateStatement (extends ASTNode)
DeleteStatement (extends ASTNode)
FromClause (extends ASTNode)
WhereClause (extends ASTNode)
OrderByClause (extends ASTNode)
Expression (extends ASTNode)
...
```

#### 1.3 Classes for Terminal Symbols

For each **terminal** symbol that carries information (has variable values):
- Create a separate class
- Inherit from `ASTNode`
- Store the token value
- Implement `print()` method

**Example Terminal Classes:**
```
Identifier (extends ASTNode) - stores column/table name
Literal (extends ASTNode) - stores literal value
NumberLiteral (extends ASTNode) - stores numeric value
StringLiteral (extends ASTNode) - stores string value
...
```

#### 1.4 Class Hierarchy Example

```
ASTNode (abstract)
├── Statements
│   ├── SelectStatement
│   ├── UpdateStatement
│   ├── DeleteStatement
│   ├── InsertStatement
│   └── ...
├── Clauses
│   ├── FromClause
│   ├── WhereClause
│   ├── OrderByClause
│   ├── GroupByClause
│   └── ...
├── Expressions
│   ├── BinaryExpression
│   ├── UnaryExpression
│   ├── FunctionCall
│   └── ...
└── Terminals
    ├── Identifier
    ├── Literal
    ├── NumberLiteral
    └── StringLiteral
```

### Step 2: Define ASTBuilderVisitor Class

Create `ASTBuilderVisitor` class that:
- Extends ANTLR 4's `BaseVisitor` class
- Implements visit methods for each grammar rule
- Visits the parse tree generated by Phase 2
- Constructs AST nodes bottom-up
- Returns the root AST node

**Visitor Implementation Pattern:**
```antlr
Visit each grammar rule
  ↓
Create corresponding AST node
  ↓
Recursively visit child rules
  ↓
Attach child nodes to parent node
  ↓
Return constructed node
```

### Step 3: Define Main Package

Create a main package with a class containing the `main()` method:

**Main Method Functionality:**
1. Read input SQL code
2. Create lexer using ANTLR 4 lexical analyzer
3. Generate tokens from input
4. Create parser from tokens
5. Generate parse tree
6. Create `ASTBuilderVisitor` instance
7. Visit parse tree with visitor
8. Generate AST
9. Print AST to console/file
10. Display AST structure

### Step 4: Implement Print Functionality

Each `ASTNode` subclass must implement:
- `print()` method for recursive tree printing
- Formatted output with indentation showing tree structure
- Display node type and relevant data
- Recursively print all child nodes

**Print Output Example:**
```
SelectStatement
├── SelectClause
│   ├── Identifier (foo)
│   └── Identifier (bar) as baz
├── FromClause
│   └── Identifier (mytable)
├── WhereClause
│   └── BinaryExpression
│       ├── Identifier (foo)
│       ├── Operator (LIKE)
│       └── StringLiteral ('%neat%')
└── OrderByClause
    ├── Identifier (foo)
    └── Direction (DESC)
```

---

## Example Query for Testing

```sql
--
-- This is an example query
--
SELECT
foo, bar as baz
FROM
mytable
WHERE
foo LIKE '%neat%'
ORDER BY
foo DESC
```

---

# Project Implementation Notes

## Design Patterns

- **Composite Design Pattern:** Used for building the AST hierarchy
- **Visitor Pattern:** Used for traversing and processing the parse tree
- **Object-Oriented Programming:** Organize code into classes and packages

## Development Approach

1. **Start Small:** Begin with basic rules and tokens
2. **Test Incrementally:** Test each phase before moving to the next
3. **Expand Gradually:** Add features one at a time
4. **Refactor:** Improve code structure as needed
5. **Document:** Keep clear documentation of grammar rules and classes

## Code Organization

```
project/
├── lexer/
│   └── SQLLexer.g4
├── parser/
│   └── SQLParser.g4
├── ast/
│   ├── ASTNode.java (abstract)
│   ├── statements/
│   │   ├── SelectStatement.java
│   │   ├── UpdateStatement.java
│   │   ├── DeleteStatement.java
│   │   └── ...
│   ├── clauses/
│   │   ├── FromClause.java
│   │   ├── WhereClause.java
│   │   └── ...
│   ├── expressions/
│   │   ├── BinaryExpression.java
│   │   ├── UnaryExpression.java
│   │   └── ...
│   └── terminals/
│       ├── Identifier.java
│       ├── Literal.java
│       └── ...
├── visitor/
│   └── ASTBuilderVisitor.java
├── main/
│   └── SQLCompiler.java
└── test/
    └── test_files/
        └── *.sql
```

---
## Evaluation Criteria
- Correctness of lexical analysis
- Completeness of grammar rules
- Proper AST construction and hierarchy
- Quality of code and documentation
- Successful compilation and execution
- Handling of edge cases and special SQL syntax

---

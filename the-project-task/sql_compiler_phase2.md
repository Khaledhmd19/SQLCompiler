# SQL Compiler Project - Phase Two

## University Information
- **University:** Damascus University - Faculty of Informatics Engineering
- **Year:** Fourth Year
- **Department:** Artificial Intelligence
- **Course:** Practical Compilers

---

## Phase Two: Syntax Analysis

### Objective

This phase aims to verify that a sequence of tokens (identified by the lexical analyzer) conforms to the grammar rules of the programming language. In our case (SQL), it answers the question: Does the sequence of tokens in the input file belong to the language generated by the Grammar?

---

## Requirements

### 1. Write Grammar Rules for SQL

Write a comprehensive set of grammar rules for SQL programming language that define the shape and structure of correct SQL statements using the ANTLR 4 parser tool. Place the rules in a Parser Grammar file.

The written rules must allow recognition of fundamental SQL instructions:

#### DML Statements
- `select_statement`
- `update_statement`
- `delete_statement`
- `insert_statement`
- ...

#### DDL Statements
- `DROP`
- `ALTER`
- `CREATE`
- ...

#### Cursor Manipulation Statements

#### Common Table Expression Statements (CTE)

### 2. Resolve Grammar Conflicts

Resolve conflicts in the grammar by using the concepts of **Associativity** and **Precedence** for arithmetic, logical operations, and others.

---

## References and Guidelines

### Documentation Reference

Use Transact-SQL documentation as a reference when writing grammar rules:
- https://learn.microsoft.com/en-us/sql/t-sql/queries/queries?view=sql-server-ver17

### Example: Understanding SQL Syntax Documentation

Let's examine the UPDATE statement from Transact-SQL documentation:

#### Official Syntax

```
[ WITH <common_table_expression> [...n] ] 
UPDATE 
 [ TOP ( expression ) [ PERCENT ] ] 
 { { table_alias | <object> | rowset_function_limited 
 [ WITH ( <Table_Hint_Limited> [ ...n ] ) ] 
 } 
 | @table_variable 
 } 
 SET 
 { column_name = { expression | DEFAULT | NULL } 
 | { udt_column_name.{ { property_name = expression 
 | field_name = expression } 
 | method_name ( argument [ ,...n ] ) 
 } 
 } 
 | column_name { .WRITE ( expression , @Offset , @Length ) } 
 | @variable = expression 
 | @variable = column = expression 
 | column_name { += | -= | *= | /= | %= | &= | ^= | |= } expression 
 | @variable { += | -= | *= | /= | %= | &= | ^= | |= } expression 
 | @variable = column { += | -= | *= | /= | %= | &= | ^= | |= } expression 
 } [ ,...n ] 
 
 [ <OUTPUT Clause> ] 
 [ FROM{ <table_source> } [ ,...n ] ] 
 [ WHERE { <search_condition> 
 | { [ CURRENT OF 
 { { [ GLOBAL ] cursor_name } 
 | cursor_variable_name 
 } 
 ] 
 } 
 } 
 ] 
 [ OPTION ( <query_hint> [ ,...n ] ) ] 
[ ; ]

<object> ::= 
{ 
 [ server_name . database_name . schema_name . 
 | database_name .[ schema_name ] . 
 | schema_name . 
 ] 
 table_or_view_name
}
```

---

## SQL Documentation Notation vs ANTLR 4 Notation

The notation used in SQL documentation differs from the notation used in ANTLR 4 grammar files. Here's how to interpret SQL syntax and convert it to ANTLR 4 rules:

### 1. Angle Brackets `<...>`

**Meaning in SQL Documentation:** Non-terminal placeholders representing grammar rules

**Example:** `<common_table_expression>`
- This indicates a grammar rule named `common_table_expression`
- This rule is defined elsewhere in the documentation (look for its definition)

**ANTLR 4 Equivalent:** Use the rule name directly
```antlr
commonTableExpression
```

---

### 2. Square Brackets `[...]`

**Meaning in SQL Documentation:** Optional elements (may appear once or not at all)

**Example:** `[ WHERE <search_condition> ]`
- This indicates the WHERE clause is optional

**ANTLR 4 Equivalent:** Use the `?` quantifier
```antlr
whereClause?
```

---

### 3. Curly Braces `{...}`

**Meaning in SQL Documentation:** Choose exactly one alternative

**Example:**
```
{ table_alias | <object> | rowset_function_limited }
```
- Choose one of these three options

**ANTLR 4 Equivalent:** Use the `|` (pipe) operator to separate alternatives
```antlr
tableAlias
| objectName
| rowsetFunctionLimited
```

---

### 4. Ellipsis `[,...n]`

**Meaning in SQL Documentation:** Repeat zero or more times (comma-separated)

**Example:** `SET a=1, b=2, c=3` in SQL
- Multiple assignments separated by commas

**ANTLR 4 Equivalent:** Use the `*` quantifier with comma separator
```antlr
assignment (',' assignment)*
```

---

### 5. Keywords in UPPERCASE

**Meaning in SQL Documentation:** Tokens (sent by the lexer)

**Example:** `UPDATE`, `SET`, `WHERE`, `FROM`
- These are recognized as tokens by the lexical analyzer

**ANTLR 4 Equivalent:** Use uppercase names in parser rules
```antlr
UPDATE | SELECT | INSERT | DELETE
```

---

## Important Notes

### Note 1: Non-Terminal vs Terminal Elements
Some symbols in documentation are neither TOKENS nor defined within `<>`. These must also be defined as rules in the parser grammar file. However, there's a difference between formally documented non-terminals like `<common_table_expression>` and informal names like `column_name`.

**Example:**
- `<common_table_expression>` is formally defined in the documentation
- `column_name` is not formally defined, so you can write its rule as:

```antlr
columnName
    : IDENTIFIER;
```

### Note 2: Use Documentation as Reference, Not Direct Translation
- Use language documentation as a reference to understand language instructions and their general structure
- **Do not** directly translate the syntax notation from documentation into grammar rules as written
- The purpose of syntax documentation is human explanation and understanding, not formal syntactic description

### Note 3: Incremental Development Approach
- Always start with a **small subset** of rules for a limited number of statements
- Then gradually add features while testing the grammar at each stage

**Example: Building SELECT Statement Progressively**

**Phase 1:** Write a simple rule accepting only basic syntax:
```sql
SELECT column1, column2 FROM table1
```

**Phase 2:** After verifying correctness, add the WHERE clause:
```sql
SELECT column1, column2 FROM table1 WHERE column1 = 'hello world'
```

**Phase 3:** Gradually extend rules to add:
- `JOIN` operations
- `GROUP BY` clause
- `ORDER BY` clause
- Other features

This incremental approach reduces complexity and helps build correct, extensible grammar rules.

---

**Good luck and success!**